<!DOCTYPE html>
<html>
<head>
	<style>
	.garden {
	  position: relative;
	  width : 1800px;
	  height: 950px;
	  border: 5px solid #CCC;
	  border-radius: 10px;
	}

	.ball {
	  position: absolute;
	  top   : 90px;
	  left  : 90px;
	  width : 10px;
	  height: 10px;
	  background: yellow;
	  border-radius: 100%;
	}
	#surface {
		position: absolute;
		width: 100%;
		height: 100%;
		/*border: 2px solid #F00;*/
	}
	body {
		background: black;
	}
	</style>
	<script src="/socket.io/socket.io.js"></script>
</head>
	<body>
		blah this is html
		<div class="garden">
			<!-- <div class="ball"> 
			</div> -->
			<canvas id="surface" width="1800" height="950">
			</canvas>
		</div>
		<pre class="output"></pre>

	<script>

var ball   = document.querySelector('.ball'); //fetching the elements (in the classes) from above
var garden = document.querySelector('.garden');
var output = document.querySelector('.output');

// TODO: un-hard-code the 20 (pixels) constant here;
var maxX = garden.clientWidth  - 20;
var maxY = garden.clientHeight - 20;

var fovX = 60;
var fovY = 45;

function clamp01(val) { if (val < 0) return 0; if (val > 1) return 1; return val; }

function fixAngle(angle) {
  if (angle > 180) return angle - 360;
  if (angle < -180) return angle + 360;
  return angle;
}
function orientationToCursor(event) {
  return {x: clamp01((fixAngle(event.alpha)/(-fovX)) + 0.5),
          y: clamp01(event.beta / (-fovY) + 0.5)};
}

var canvas = document.querySelector("#surface");
var ctx = canvas.getContext('2d');
ctx.fillStyle = "black";
ctx.fillRect(0, 0, width, height);
ctx.strokeStyle = "blue";
var width = canvas.width;
var height = canvas.height;

var users = {};

function drawCurve(ctx, pts) {
	if (pts.length < 3) return;
	ctx.beginPath();
	// TODO: draw an actual curve here
	ctx.moveTo(pts[0].x, pts[0].y);

	for(var i = 1; i < pts.length - 2; i++) {
		var xc = (pts[i].x + pts[i+1].x) * 0.5;
		var yc = (pts[i].y + pts[i+1].y) * 0.5;
		ctx.quadraticCurveTo(pts[i].x, pts[i].y, xc, yc);
		//ctx.lineTo(pts[i].x, pts[i].y);
	}
	ctx.quadraticCurveTo(pts[i].x, pts[i].y, pts[i+1].x, pts[i+1].y);
	ctx.stroke();
}


function createBall(userId) {
	// TODO:
	var ball = document.createElement("div");
	ball.className = "ball";
	document.querySelector(".garden").appendChild(ball);
	return ball;
}

function createRandomWalker(startX, startY) {
	var pts = [{x: startX, y: startY}];
	var lastX = startX,
		lastY = startY,
		newInfo = false;

	var MAX_UPDATES = 150;
	var framesSinceUpdate = 0;

	function addPoint(x, y) {
		pushNewPoints(pts, {"x" : x, "y" : y});
		newInfo = true;
		framesSinceUpdate = 0;
	}

	function draw() {
		if (newInfo) {
			ctx.strokeStyle = "blue";
			ctx.beginPath(); //collect data xy to draw
			ctx.moveTo(lastX, lastY);
			ctx.lineTo(pts[pts.length - 1].x, pts[pts.length - 1].y);
			ctx.stroke(); //DRAW IT!
			lastX = pts[pts.length - 1].x;
			lastY = pts[pts.length - 1].y;

			newInfo = false;
		}
		ctx.strokeStyle = "#050505";
		randomWalk(pts);
		drawCurve(ctx, pts);
		framesSinceUpdate++;
	}

	function alive() {
		return framesSinceUpdate < MAX_UPDATES;
	}
	return {
		"addPoint" : addPoint,
		"draw" : draw,
		"alive" : alive
	};
}

function createUser(userId) {
	var first = true;

	var lastX = 0,
		lastY = 0;

	var touchState = 0; // if state == 1 then draw

	var ball = createBall(userId);

	var strokes = [];
	var currentStroke = null;
	// TODO: remove
	var pts = [];

	function handleOrientation(event) {
	  lastX = event[0] * width;
	  lastY = event[1] * height;
	  if (first) {
	  	first = false;
	  	return;
	  }

	  var newTouchState = event[2];
	  if (newTouchState != touchState) {
	  	touchState = newTouchState;
	  	if (touchState == 1) {
	  		//console.log("starting stroke!");
	  		var newStroke = createRandomWalker(lastX, lastY);
	  		strokes.push(newStroke);
	  		currentStroke = newStroke;
	  	} else {
	  		// TODO: notify stroke?
	  		currentStroke = null;
	  	}
	  } else if (touchState == 1) {
	  	// if drawing already
	  	currentStroke.addPoint(lastX, lastY);
	  }


	  // 10 is half the size of the ball
	  // It center the positioning point to the center of the ball
	  ball.style.top  = (maxY*event[1]) + "px";
	  ball.style.left = (maxX*event[0]) + "px";
	}

	function draw() {
		for (var i = 0; i < strokes.length; i++) {
			strokes[i].draw();
		}
		// remove dead strokes
		while ((strokes.length > 0) && (!strokes[0].alive())) {
			//console.log("clearing stroke");
			strokes.shift();
		}
	}

	function remove() {
		ball.parentNode.removeChild(ball);
	}

	return {
		"draw": draw,
		"handleOrientation": handleOrientation,
		"remove": remove
	};
}

var ors = {};
function receivedOrientations(orientations) {
	var usersAfterUpdate = {};
	// for every user we got an orientation from the server:
	// 
	ors = orientations;
	for(userId in orientations) {
		if (orientations.hasOwnProperty(userId)) {
			var user = users[userId];
			if (user === undefined) {
				console.log('new user detected: ' + userId);
				user = createUser(userId);
				console.log(user);
			}
			user.handleOrientation(orientations[userId]);
			usersAfterUpdate[userId] = user;
			// remove user from old users list, so we can check for disconnected users
			delete users[userId];
		}
	}
	// check if there are users left in old user list, if so delete them
	for(userId in users) {
		if (users.hasOwnProperty(userId) && (users[userId] !== undefined)) {
			console.log('disconnected user: ' + userId);
			users[userId].remove();
		}
	}

	users = usersAfterUpdate;
}

var socket = io();
socket.on('connect', function() {
	socket.emit("server-started");
});
//socket.on("orientation", handleOrientation); //getting the info from the accelerometer
socket.on("orientations", receivedOrientations);

function pushNewPoints(ptsList, newDest) {
	var lastPt = ptsList[ptsList.length - 1];

	// 1 subdivision per 10 pixels;
	var subdivisions = Math.floor(Math.sqrt((lastPt.x-newDest.x)*(lastPt.x-newDest.x) + (lastPt.y-newDest.y)) / 10);
	for(var i = 1; i < subdivisions - 1; i++) {
		var t = i / subdivisions;
		ptsList.push({x: t*newDest.x + (1-t)*lastPt.x,
					  y: t*newDest.y + (1-t)*lastPt.y});
		// TODO: hideous
		if (ptsList.length > 200) {
			ptsList.shift();
		}
	}
	ptsList.push(newDest);
	// TODO: hideous
	if (ptsList.length > 200) {
		ptsList.shift();
	}
}

function randomWalk(ptsList) {
	for(var i = 0; i < ptsList.length; i++) {
		ptsList[i].x += 1.5*(Math.random() - 0.5);
		ptsList[i].y += 1.5*(Math.random() - 0.5);
	}
}


function createEraser(secondsPerCycle) {
	var startTime = +new Date,
		lastTime = startTime;
	// 
	function timeToAngle(t) {
		return (((t - startTime)/1000) % secondsPerCycle / secondsPerCycle) * Math.PI * 2;
	}
	function draw() {
		var currentTime = +new Date,
			lastAngle = timeToAngle(lastTime),
			currentAngle = timeToAngle(currentTime);
		lastTime = currentTime;

		// clear swept volume since last call
		// TODO: hack - if deletion line width is equal to line width when drawing clock hand,
		// we get some left-over pixels due to antialiasing. they leave cool moire patterns, but still
		ctx.lineWidth = 12; 
		ctx.strokeStyle = 'black';
		ctx.fillStyle = 'black';
		ctx.beginPath();
		ctx.moveTo(width / 2, height / 2);
		var dxOld = Math.cos(lastAngle),
			dyOld = Math.sin(lastAngle),
			dx = Math.cos(currentAngle),
			dy = Math.sin(currentAngle);
		// TODO: assuming time between calls is enough for less than 1/4th of a cycle
		// TODO: assuming width > height - counting on canvas to do clipping
		ctx.lineTo((width / 2) + dxOld*width, (height / 2) + dyOld*width);
		ctx.lineTo((width / 2) + dx*width, (height / 2) + dy*width);
		ctx.closePath();
		ctx.fill();
		ctx.stroke();
		// draw the hand of the clock
		ctx.lineWidth = 10; // TODO: un-hardcode
		ctx.strokeStyle = "white";
		ctx.beginPath();
		ctx.moveTo(width / 2, height / 2);
		ctx.lineTo((width / 2) + dx*width, (height / 2) + dy*width);
		ctx.stroke();
	}
	return {"draw": draw};
}

var eraser = createEraser(30);

function updateDisplay() {
	// draw all strokes
	ctx.globalCompositeOperation = 'lighter';
	ctx.lineWidth = 1;
	for (var userId in users) {
		if (users.hasOwnProperty(userId)) {
			users[userId].draw();
		}
	}
	// draw image 
	ctx.globalCompositeOperation = 'source-over';
	eraser.draw();
	// request next frame
	window.requestAnimationFrame(updateDisplay);
}

function takeAndSendScreenshot() {
	var data = canvas.toDataURL("image/png");
    var ajax = new XMLHttpRequest();
   ajax.open('POST', '/save-image');
   ajax.setRequestHeader('Content-Type', 'application/octet-stream');
   ajax.onreadystatechange = function() {
        console.log(ajax.responseText);
    }
   ajax.send(data);
   console.log('took screenshot');
   crap = data;
}

setTimeout(takeAndSendScreenshot, 4000);

window.requestAnimationFrame(updateDisplay);

	</script>

	</body>
</html>